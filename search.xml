<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[推荐算法]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[推荐算法1一、基于内容content based引入item属性的ceontent based推荐==框架实现流程==： 输入items 1234正排表movieId1 战争、movieId2 喜剧、 内容分析 正排表 –&gt; 倒排表 1234倒排表战争 movieId1 、movieId3 。。。喜剧 movieId2 、movieId4 。。。 优缺点 无个性化 引入User属性的ceontent based推荐==框架实现流程==： 优缺点： ++马太效应++ 二、基于协同过滤collaboration Filtering三、实战之倒排表（基于content based） 分隔符^A的输入方法，ctrl+v–crtl+A 输入items： 123456789//音乐列表：id + name8920397333 王铮亮 时间都去哪了 《私人订制》插曲8920408333 Locked Out Of Heaven 音乐高清视频MV8920422333 影视-心上人啊快给我力量KTV（电影《神圣的使命》插曲8920491333 068_奥特曼8920492333 影视-幸福不会从天降KTV（电影《我们村里的年轻人》插8920527333 邓紫棋 GEM 2013 X.X.X. LIVE 演唱会 【全场高清】8920529333 067_外婆的澎湖湾8920588333 卓依婷-纸飞机 内容分析 step1： 对name进行中文分词、关键词提取，根据TF-IDF 1234567891011121314151617181920//利用jieba分词工具#encoding=utf-8import jiebaimport jieba.possegimport jieba.analyses = &quot;王铮亮 时间都去哪了 《私人订制》插曲&quot;for x, w in jieba.analyse.extract_tags(s, withWeight=True): print(&apos;%s %s&apos; % (x, w))// 输出----------------------------------------TF-IDF----------------------------------------铮亮 2.64150609428订制 2.1209681572插曲 1.94525807642私人 1.3649737576时间 0.815907926492 step2： 生成正排表 123456 8920397333 王铮亮 时间都去哪了 《私人订制》插曲 铮亮2.64150609428订制2.1209681572插曲1.94525807642私人1.3649737576时间0.815907926492 ... setp3： 生成倒排表 ==map-reduce思想==： 正排–&gt;倒排 123456789//map; token=关键词，map输出按toker排序print &apos;\t&apos;.join([token, music_name, weight])// 输出----------------------------------------铮亮 王铮亮 时间都去哪了 《私人订制》插曲 2.64150609428铮亮 音乐资讯、【720P】王铮亮Reno-迷悟MV(完整HD版) 1.32075304714。。。---------------------------------------- 123456789101112131415161718192021222324252627//reduce；相同token，按weight排序后，进行join起来def reducer_func(): cur_token = None m_list = [] for line in sys.stdin: ss = line.strip().split(&apos;\t&apos;) if len(ss) != 3: continue token = ss[0].strip() name = ss[1].strip() weight = float(ss[2].strip()) if cur_token == None: cur_token = token if cur_token != token: final_list = sorted(m_list, key=lambda x: x[1], reverse=True) print &apos;\t&apos;.join([cur_token, &apos;^A&apos;.join([&apos;^B&apos;.join([name_weight[0], str(name_weight[1])]) for name_weight in final_list])]) cur_token = token m_list = [] m_list.append((name, weight)) final_list = sorted(m_list, key=lambda x: x[1], reverse=True) print &apos;\t&apos;.join([cur_token, &apos;^A&apos;.join([&apos;^B&apos;.join([name_weight[0], str(name_weight[1])]) for name_weight in final_list])]) Results: 1234//关键词+关键词在不同歌曲中的TF-IDF值排序铮亮 王铮亮 时间都去哪了 《私人订制》插曲^B2.64150609428^A最新音乐资讯、【720P】王铮亮Reno-迷悟MV(完整HD版)^B1.32075304714私人 王铮亮 时间都去哪了 《私人订制》插曲^B1.3649737576^A解放 (电影《私人订制》主题曲)^B1.3649737576。。。 计算任意两个item之间的相似度得分 倒排表的物理意义： 不同的item被同一个token关联起来，且每一个item的分数代表着，该token所能决定该item的能力。分数越高，说明这个token越能代表这个item所要表达的含义。 因此，我们把相同token，关联起来的任意两个item的得分相乘，得到的便是这两个item的相似度了。 以上面两条倒排表记录，来做个例子： token1–&gt;==铮亮== item1–&gt;{ ++王==铮亮== 时间都去哪了 《私人订制》插曲++ } score1–&gt;2.64150609428 item2–&gt;{ ++最新音乐资讯、【720P】王==铮亮==Reno-迷悟MV(完整HD版)++ } score2–&gt;1.32075304714 那么item1 和 item2的相似度是score1*score2 token2： ==私人== 同理可计算： ++王铮亮 时间都去哪了 《==私==人订制》插曲++ ++解放 (电影《==私人==订制》主题曲)++ 相似度得分： 1.3649737576 1.3649737576 &lt; 2.64150609428 1.32075304714 因此根据分数排名可知： ++王铮亮 时间都去哪了 《私人订制》插曲++ 与 ++最新音乐资讯、【720P】王==铮亮==Reno-迷悟MV(完整HD版)++ 更为相似。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F17%2Fhello-world%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
  
  
</search>
